(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{444:function(t,s,r){"use strict";r.r(s);var v=r(0),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("介绍")]),t._v(" "),s("p",[t._v("编程思想学习笔记")])]),t._v(" "),s("h1",{attrs:{id:"编程思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编程思想"}},[t._v("#")]),t._v(" 编程思想")]),t._v(" "),s("h2",{attrs:{id:"是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[t._v("#")]),t._v(" 是什么？")]),t._v(" "),s("p",[t._v("是能够使我们的代码，去"),s("strong",[t._v("承载")]),t._v("项目中很"),s("strong",[t._v("复杂的业务逻辑")]),t._v("，并且使我的代码看起来非常的简洁易懂，并且"),s("strong",[t._v("易于扩展。")])]),t._v(" "),s("p",[s("strong",[t._v("业务逻辑三要点")])]),t._v(" "),s("ol",[s("li",[t._v("流程环节")]),t._v(" "),s("li",[t._v("人机交互")]),t._v(" "),s("li",[t._v("数据交互")])]),t._v(" "),s("p",[t._v("业务逻辑就是完成一个功能最小的一个闭环")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/XpRJqjwM5sdf91Q.png",alt:"image-20220706101108901"}})]),t._v(" "),s("p",[s("strong",[t._v("易于扩展")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/Kg6mZ57AoqpvQt3.png",alt:"image-20220706101459610"}})]),t._v(" "),s("h2",{attrs:{id:"三劝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三劝"}},[t._v("#")]),t._v(" 三劝")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("去悟")])]),t._v(" "),s("li",[s("strong",[t._v("去打磨")])]),t._v(" "),s("li",[s("strong",[t._v("去加深理解")])])]),t._v(" "),s("h2",{attrs:{id:"设计思想核心-高内聚-低耦合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计思想核心-高内聚-低耦合"}},[t._v("#")]),t._v(" 设计思想核心：高内聚，低耦合")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/RZ8jK3iWkFVxUBI.png",alt:"image-20220706102123520"}})]),t._v(" "),s("p",[s("strong",[t._v("首先来理解下什么是模块？")])]),t._v(" "),s("p",[s("strong",[t._v("模块")])]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("接口:指模块的输入和输出")])]),t._v(" "),s("li",[s("strong",[t._v("功能:指模块实现什么功能")])]),t._v(" "),s("li",[s("strong",[t._v("逻辑:指模块的内部如何实现要求的功能，以及所需要的数据。")])]),t._v(" "),s("li",[s("strong",[t._v("状态:指模块调用与被调用的关系。")])])]),t._v(" "),s("p",[s("strong",[t._v("模块由以上四部分组成")])]),t._v(" "),s("p",[s("strong",[t._v("小到一个方法、一个接口、一个类，大到一个业务，一个功能，一个系统，都是模块。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/FxyNT54lbEZMCPJ.png",alt:"image-20220706102603339"}})]),t._v(" "),s("p",[s("strong",[t._v("高内聚：模块内部元素具有相同特点的相似程度")])]),t._v(" "),s("p",[s("strong",[t._v("低耦合：模块之间的依赖程度")])]),t._v(" "),s("p",[t._v("例子：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/CH81vkS6UAyIjZO.png",alt:"image-20220706102911038"}})]),t._v(" "),s("p",[s("strong",[t._v("简单来说就是一个模块内部之间关联性高不高，新闻管理类内部元素应该都是跟新闻管理相关的，而用户注册明显跟新闻不相关")])]),t._v(" "),s("h3",{attrs:{id:"低内聚引发的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#低内聚引发的问题"}},[t._v("#")]),t._v(" 低内聚引发的问题")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("改变一个功能会影响更多功能")])]),t._v(" "),s("li",[s("strong",[t._v("不易于管理，相当于本来一个模块，分开放，每次改动都需要比改动一个模块做更多的事")])]),t._v(" "),s("li",[s("strong",[t._v("可读性差")])]),t._v(" "),s("li",[s("strong",[t._v("可靠性低")])])]),t._v(" "),s("h3",{attrs:{id:"高内聚优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高内聚优点"}},[t._v("#")]),t._v(" 高内聚优点")]),t._v(" "),s("p",[s("strong",[t._v("高内聚提供了更好的程序可靠性、可读性。")])]),t._v(" "),s("h3",{attrs:{id:"低耦合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#低耦合"}},[t._v("#")]),t._v(" 低耦合")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/zO52HXx84ybgYSI.png",alt:"image-20220706104125718"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/g6shWSRV7wtbiqj.png",alt:"image-20220706104400632"}})]),t._v(" "),s("h3",{attrs:{id:"低耦合优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#低耦合优点"}},[t._v("#")]),t._v(" 低耦合优点")]),t._v(" "),s("p",[s("strong",[t._v("低耦合提供了更好的程序可扩展性和可复用性")])]),t._v(" "),s("h3",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[s("strong",[t._v("高内聚、低耦合提供了程序更好可读性、稳定性、可扩展性和可复用性")])]),t._v(" "),s("p",[s("strong",[t._v("能够使我们的代码，去承载项目中很复杂的业务逻辑，并且使我的代码看起来非常的简洁易懂，并且易于扩展。")])]),t._v(" "),s("p",[s("strong",[t._v("高内聚，低耦合实际上是指导我们设计程序的思想")])]),t._v(" "),s("h2",{attrs:{id:"设计原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[t._v("#")]),t._v(" 设计原则")]),t._v(" "),s("p",[s("strong",[t._v("设计原则实际上是高内聚，低耦合的具体呈现，起承上启下的作用")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/IqCF75ZeERxkvUB.png",alt:"image-20220706105210309"}})]),t._v(" "),s("h3",{attrs:{id:"七大设计原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七大设计原则"}},[t._v("#")]),t._v(" 七大设计原则")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("单一职责原则")])]),t._v(" "),s("li",[s("strong",[t._v("开放封闭原则")])]),t._v(" "),s("li",[s("strong",[t._v("依赖倒置原则")])]),t._v(" "),s("li",[s("strong",[t._v("里式替换原则")])]),t._v(" "),s("li",[s("strong",[t._v("接口分离原则")])]),t._v(" "),s("li",[s("strong",[t._v("迪米特原则")])]),t._v(" "),s("li",[s("strong",[t._v("合成复用原则")])])]),t._v(" "),s("p",[s("strong",[t._v("下面的每一个原则都会为上一个原则打下基础，可以称上面的原则实现需要兼容实现下面的原则")])]),t._v(" "),s("h3",{attrs:{id:"一、单一职责原则-single-responsibility-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、单一职责原则-single-responsibility-principle"}},[t._v("#")]),t._v(" 一、单一职责原则(Single Responsibility Principle)")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/keUEGxmW5onHtvc.png",alt:"image-20220706105753732"}})]),t._v(" "),s("h4",{attrs:{id:"描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[t._v("#")]),t._v(" 描述:")]),t._v(" "),s("p",[t._v("应该有且只有一个引起类变更的原因。")]),t._v(" "),s("p",[t._v("通俗来说就是一个类或方法只干一件事")]),t._v(" "),s("h4",{attrs:{id:"优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点:")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("提高代码的可读性，提高系统的可维护性。")])]),t._v(" "),s("li",[s("strong",[t._v("降低类的复杂性，一个模块只负责一个职责，提高系统的可扩展性和可维护性。")])]),t._v(" "),s("li",[s("strong",[t._v("降低变更引起的风险。变更是必然的，如果单一职责做得好，当修改一个功能的时候可以显著的降低对另一个功能的影响。")])])]),t._v(" "),s("h3",{attrs:{id:"二、开放封闭原则open-closed-principle-ocp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、开放封闭原则open-closed-principle-ocp"}},[t._v("#")]),t._v(" 二、开放封闭原则Open Closed Principle (OCP)")]),t._v(" "),s("h4",{attrs:{id:"描述-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述-2"}},[t._v("#")]),t._v(" 描述:")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("开放封闭原则是面向对象所有原则的核心.")])]),t._v(" "),s("li",[s("strong",[t._v("对功能扩展开放、面向修攸代码封闭")])]),t._v(" "),s("li",[s("strong",[t._v("需求改变时，在不改变软件实体源代码(类、接口、方法等)的前提下，通过扩展功能，使其满足新的需求.")])])]),t._v(" "),s("p",[s("strong",[t._v("简单来说就是留条后路方便扩展，不要钻牛角尖，改代码是必然的，但不要牵一动百，要做到改一个点就能实现功能")])]),t._v(" "),s("p",[s("strong",[t._v("面向抽象编程")])]),t._v(" "),s("p",[s("strong",[t._v("使用抽象，封装变化")])]),t._v(" "),s("p",[s("strong",[t._v("更简洁的往往是更抽象的")])]),t._v(" "),s("h3",{attrs:{id:"三、依赖倒置原则dependence-inversion-principle-dip"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、依赖倒置原则dependence-inversion-principle-dip"}},[t._v("#")]),t._v(" 三、依赖倒置原则Dependence Inversion Principle (DIP)")]),t._v(" "),s("h4",{attrs:{id:"描述-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述-3"}},[t._v("#")]),t._v(" 描述:")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("高层模块不应该依赖于低层模块。两个都应该依赖于抽象。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/GfnKQzLMkxDFZc1.png",alt:"image-20220706160942718"}})])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("抽象不应该依赖细节，细节应该依赖于抽象。")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("「依赖倒置原则」的本质就是通过抽像(接口或抽像类)使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。")])])])]),t._v(" "),s("p",[t._v("开放封闭原则:")]),t._v(" "),s("p",[t._v("「开放封闭原则」是面向对象设计的终极目标，而「依赖倒置原则」是实现「开放封闭原则」的基础。")]),t._v(" "),s("p",[t._v("如果「开放封闭原则」是设计大楼的蓝图，那么「依赖倒置原则」就是大楼的钢铁架构。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/YRwtHnKEoU5AgzN.png",alt:"image-20220706161658274"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/fwOH8WFTqr7RNla.png",alt:"image-20220706161740524"}})]),t._v(" "),s("h4",{attrs:{id:"关于依赖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于依赖"}},[t._v("#")]),t._v(" 关于依赖")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("一个优秀的面向对象程序设计，核心的原则之一就是将变化「隔离」/「封装」，使得变化部分发生变化时，其他部分，不受影响。")])]),t._v(" "),s("li",[s("strong",[t._v("为了实现这个目的，需要使用面向接口编程，使用后，客户类，不再直接依赖服务类，而是依赖一个抽象的接口，这样，客户类就不能在内部直接实例化服务类。")])]),t._v(" "),s("li",[s("strong",[t._v("但是客户类在运行的过程中，又需要具体的服务类来提供服务，因为接口是不能实例化的，就产生了一个矛盾:客户类不允许实例化服务类，但是客户类又需要服务类的服务。")])]),t._v(" "),s("li",[s("strong",[t._v("为了解决这个矛盾，我们设计了一种解决方案，既:客户类定义一个注入点，用于服务类的注入，而客户类的客户类(Program类) 负责根据情况，实例化服务类，注入到客户类中，从而解决了这个矛盾。")])])]),t._v(" "),s("p",[s("strong",[t._v("简称：依赖注入")])]),t._v(" "),s("p",[t._v("三种注入方式")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("接口注入")])]),t._v(" "),s("li",[s("strong",[t._v("构造函数注入")])]),t._v(" "),s("li",[s("strong",[t._v("方法注入")])])]),t._v(" "),s("h3",{attrs:{id:"四、里式替换原则liskov-substitution-principle-lsp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、里式替换原则liskov-substitution-principle-lsp"}},[t._v("#")]),t._v(" 四、里式替换原则Liskov Substitution Principle (LSP)")]),t._v(" "),s("h4",{attrs:{id:"描述-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述-4"}},[t._v("#")]),t._v(" 描述:")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("如果S是T的子类型，则T类型的对象可以替换为S类型的对象。")])]),t._v(" "),s("li",[s("strong",[t._v("所有引用父类对象的地方，都可以使用其子类型代替。")])]),t._v(" "),s("li",[s("strong",[t._v("子类可以替换父类。")])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/67V9OroEnL2HxZ3.png",alt:"image-20220706163524408"}})]),t._v(" "),s("h3",{attrs:{id:"五、接口分离原则interface-segragation-principle-isp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、接口分离原则interface-segragation-principle-isp"}},[t._v("#")]),t._v(" 五、接口分离原则Interface Segragation Principle (ISP)")]),t._v(" "),s("h4",{attrs:{id:"描述-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述-5"}},[t._v("#")]),t._v(" 描述:")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("客户端不应该依赖它不需要的接口。")])]),t._v(" "),s("li",[s("strong",[t._v("一个类对另一个类的依赖应该建立在最小接口上。")])]),t._v(" "),s("li",[s("strong",[t._v("接口尽量细分，不要在一个接口中放很多方法。")])])]),t._v(" "),s("p",[t._v("单一职责原则实现高内聚")]),t._v(" "),s("p",[t._v("接口分离原则实现低耦合")]),t._v(" "),s("p",[s("strong",[t._v("注意：")])]),t._v(" "),s("p",[t._v("​\t\t"),s("strong",[t._v("根据接口隔离原则拆分接口时，首先必须满足单一职责原则")])]),t._v(" "),s("h3",{attrs:{id:"六、迪米特原则the-least-knowledge-principle-demeter-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、迪米特原则the-least-knowledge-principle-demeter-principle"}},[t._v("#")]),t._v(" "),s("strong",[t._v("六、迪米特原则The Least Knowledge Principle/Demeter Principle")])]),t._v(" "),s("h4",{attrs:{id:"描述-6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述-6"}},[t._v("#")]),t._v(" 描述:")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("它要求一个对象应该对其他对象有最少的了解。(最少知识原则)")])]),t._v(" "),s("li",[s("strong",[t._v("降低类之间的耦合。")])]),t._v(" "),s("li",[s("strong",[t._v("迪米特法则实际上就是一个类在创建方法和属性时要遵守的法则。")])])]),t._v(" "),s("p",[s("strong",[t._v("重要：迪米特原则:只和直接朋友通信!")])]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("成员对象")])]),t._v(" "),s("li",[s("strong",[t._v("方法参数")])]),t._v(" "),s("li",[s("strong",[t._v("方法返回值")])]),t._v(" "),s("li",[s("strong",[t._v("注意:出现在局部变量中的类，不是直接朋友")])])]),t._v(" "),s("p",[s("strong",[t._v("简单来说就是不要直接引用外部类，比如在方法内部设置变量保存外部类实例，而应该用过参数传递")])]),t._v(" "),s("h3",{attrs:{id:"七、合成复用原则composite-reuse-principle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七、合成复用原则composite-reuse-principle"}},[t._v("#")]),t._v(" 七、合成复用原则Composite Reuse Principle")]),t._v(" "),s("h4",{attrs:{id:"描述-7"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述-7"}},[t._v("#")]),t._v(" 描述:")]),t._v(" "),s("ol",[s("li",[t._v("合成复用原则，又称为组合/聚合复用原则。")]),t._v(" "),s("li",[t._v("尽量使用对象组合，而不是继承来达到复用。")])]),t._v(" "),s("h4",{attrs:{id:"如何实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现"}},[t._v("#")]),t._v(" 如何实现？")]),t._v(" "),s("p",[s("strong",[t._v("首先先来看看继承的问题")])]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("破坏了系统的封装性，基类发生了改变，子类的实现也会发生改变。")])]),t._v(" "),s("li",[s("strong",[t._v("子类如果不需要Method3,则系统耦合性变高。")])]),t._v(" "),s("li",[s("strong",[t._v("继承是静态的，不能在程序运行时发生改变。")])])]),t._v(" "),s("p",[s("strong",[t._v("看是has关系还是is关系")])]),t._v(" "),s("p",[t._v("举个例子，学生与人")]),t._v(" "),s("p",[t._v("学生是人所以学生类要继承人类")]),t._v(" "),s("p",[t._v("麻雀有翅膀，鸡也有翅膀")]),t._v(" "),s("p",[t._v("所以鸡，和麻雀都应该组合翅膀")]),t._v(" "),s("h4",{attrs:{id:"总结-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[t._v("#")]),t._v(" 总结：")]),t._v(" "),s("p",[s("strong",[t._v("合成复用原则是将已有的对象纳入到新对象中，作为新对象的对象成员来实现的，新对象可以调用已有对象的功能，从而达到复用。")])]),t._v(" "),s("h3",{attrs:{id:"核心要点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心要点"}},[t._v("#")]),t._v(" 核心要点")]),t._v(" "),s("p",[s("strong",[t._v("组合、聚合、依赖....是什么？")])]),t._v(" "),s("p",[s("strong",[t._v("他们都是类与类之间的关系:泛化、实现、组合、聚合、关联、依赖")])]),t._v(" "),s("h4",{attrs:{id:"类图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类图"}},[t._v("#")]),t._v(" 类图")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/sODruIVJLXYe7R1.png",alt:"image-20220706173520447"}})]),t._v(" "),s("h5",{attrs:{id:"泛化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#泛化"}},[t._v("#")]),t._v(" "),s("strong",[t._v("泛化")])]),t._v(" "),s("p",[s("strong",[t._v("泛化就是继承")]),t._v("，用实线加箭头")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/fYZ9g6PKCt5msrH.png",alt:"image-20220706173611347"}})]),t._v(" "),s("h5",{attrs:{id:"实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),s("p",[t._v("类与接口的关系，表示类实现了接口，用虚线加箭头")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/Hpk8D2XAw46QrRg.png",alt:"image-20220706173746523"}})]),t._v(" "),s("h5",{attrs:{id:"组合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合"}},[t._v("#")]),t._v(" 组合")]),t._v(" "),s("p",[t._v("组合是整体和部分的关系，部分没有独立的生命周期，组合是把部分作为整体类的对象")]),t._v(" "),s("p",[s("strong",[t._v("就是创建tiger类的时候也得创建leg类，得同时存在或消失（强拥有）")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/HZ2ANt49lWCVbyz.png",alt:"image-20220706174247227"}})]),t._v(" "),s("h5",{attrs:{id:"聚合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#聚合"}},[t._v("#")]),t._v(" 聚合")]),t._v(" "),s("p",[t._v("聚合也是整体与部分的关系，但是个体有独立的生命周期，聚合是把个体对象的指针(引用)作为整体类的属性（弱拥有）")]),t._v(" "),s("p",[s("strong",[t._v("就是老虎可以在虎群也可以不在虎群")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/bjIDraSCp8RkwgY.png",alt:"image-20220706174626412"}})]),t._v(" "),s("h5",{attrs:{id:"关联"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关联"}},[t._v("#")]),t._v(" 关联")]),t._v(" "),s("p",[t._v("关联是一种拥有关系，它使一个类知道另一个类的属性和方法。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/jEaVMTZqO8ipnYC.png",alt:"image-20220706174922787"}})]),t._v(" "),s("h5",{attrs:{id:"依赖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖"}},[t._v("#")]),t._v(" 依赖")]),t._v(" "),s("p",[t._v("依赖是一种使用关系")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/U2fDegNGX8V6yhk.png",alt:"image.png"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://s2.loli.net/2022/07/06/I7b4Zz2T5POyLNH.png",alt:"image.png"}})])])}),[],!1,null,null,null);s.default=_.exports}}]);